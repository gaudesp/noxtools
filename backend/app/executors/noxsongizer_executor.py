"""Executor responsible for running Demucs for Noxsongizer jobs."""

from __future__ import annotations

import shutil
import subprocess
import tempfile
import time
from pathlib import Path
from typing import List, Tuple

from app.models.job import Job
from app.workers.job_worker import CancellationToken, JobCancelled


class NoxsongizerExecutor:
  """
  Isolated executor that runs Demucs for a given job input.

  Handles temporary output directories, subprocess execution, and moves the
  generated stems into the final job output folder.
  """

  def __init__(self, *, demucs_bin: str = "demucs", demucs_model: str = "htdemucs_ft", base_output: Path | None = None) -> None:
    """
    Initialize the executor.

    Args:
      demucs_bin: Demucs CLI executable.
      demucs_model: Demucs model name.
      base_output: Base directory for final outputs; defaults to media/outputs.
    """
    self.demucs_bin = demucs_bin
    self.demucs_model = demucs_model
    self.base_output = base_output or Path("media/noxsongizer/outputs")
    self.base_output.mkdir(parents=True, exist_ok=True)

  def execute(self, job: Job, cancel_token: CancellationToken | None = None) -> Tuple[Path, List[str]]:
    """
    Run Demucs for the given job.

    Args:
      job: Job containing an input_path to process.

    Returns:
      A tuple of (final_output_dir, list_of_stems).

    Raises:
      ValueError: If input_path is missing or file does not exist.
      RuntimeError: If Demucs fails or outputs cannot be processed.
    """
    if cancel_token:
      cancel_token.raise_if_cancelled()

    if not job.input_path:
      raise ValueError("Input file is missing")

    input_file = Path(job.input_path)
    if not input_file.exists():
      raise ValueError("Input file not found on disk")

    final_output_dir = self.base_output / job.id
    final_output_dir.mkdir(parents=True, exist_ok=True)

    input_stem = input_file.stem or "output"
    temp_dir = Path(tempfile.mkdtemp(prefix=f"{job.id}_", dir=str(self.base_output)))
    try:
      completed = self._run_demucs(input_file, temp_dir, cancel_token)
      if completed.returncode != 0:
        stderr = (completed.stderr or "").strip()
        raise RuntimeError(stderr or "Demucs failed")

      demucs_output_folder = self._locate_demucs_outputs(input_file, temp_dir)
      if not demucs_output_folder:
        raise RuntimeError("Demucs output folder not found")

      stems = self._move_outputs(demucs_output_folder, final_output_dir, input_stem)
      if not stems:
        raise RuntimeError("No stems generated by Demucs")

      return final_output_dir, stems
    finally:
      self._cleanup(temp_dir)

  def _run_demucs(
    self,
    input_file: Path,
    output_dir: Path,
    cancel_token: CancellationToken | None = None,
  ) -> subprocess.CompletedProcess[str]:
    """
    Invoke Demucs and return the completed process.

    Args:
      input_file: Input audio file to separate.
      output_dir: Target directory for Demucs outputs.
    """
    cmd = [
      self.demucs_bin,
      "-n",
      self.demucs_model,
      "-o",
      str(output_dir),
      str(input_file),
    ]
    return self._run_with_cancellation(cmd, cancel_token)

  def _locate_demucs_outputs(self, input_file: Path, base_dir: Path) -> Path | None:
    """
    Locate the Demucs output folder inside the temp directory.

    Args:
      input_file: Original input file.
      base_dir: Base directory where Demucs wrote its outputs.
    """
    candidate = base_dir / self.demucs_model / input_file.stem
    if candidate.exists():
      return candidate
    matches = list((base_dir / self.demucs_model).glob(f"{input_file.stem}*"))
    return matches[0] if matches else None

  def _move_outputs(self, source_dir: Path, target_dir: Path, input_stem: str) -> List[str]:
    """
    Move stem files from the Demucs output directory to the job output dir.

    Args:
      source_dir: Directory containing Demucs outputs.
      target_dir: Destination directory for the stems.
      input_stem: Stem of the original input filename for renamed outputs.
    """
    stems: List[str] = []
    for stem_path in source_dir.iterdir():
      if not stem_path.is_file():
        continue
      label = self._label_for_stem(stem_path.stem)
      renamed = f"[{label}] {input_stem}{stem_path.suffix}"
      target = target_dir / renamed
      shutil.move(str(stem_path), str(target))
      stems.append(renamed)
    return stems

  def _label_for_stem(self, stem_name: str) -> str:
    """
    Map Demucs stem names to user-facing labels.
    """
    mapping = {
      "vocals": "Vocals",
      "other": "Other",
      "bass": "Bass",
      "drums": "Drums",
    }
    return mapping.get(stem_name.lower(), stem_name.title())

  def _cleanup(self, path: Path) -> None:
    """Best-effort cleanup of temporary directories."""
    try:
      if path.exists():
        shutil.rmtree(path)
    except Exception:
      pass

  def _run_with_cancellation(
    self,
    cmd: list[str],
    cancel_token: CancellationToken | None = None,
  ) -> subprocess.CompletedProcess[str]:
    """
    Run a subprocess while allowing cooperative cancellation.
    """
    proc = subprocess.Popen(
      cmd,
      stdout=subprocess.PIPE,
      stderr=subprocess.PIPE,
      text=True,
    )

    try:
      while True:
        if cancel_token and cancel_token.cancelled:
          proc.terminate()
          try:
            proc.wait(timeout=5)
          except Exception:
            proc.kill()
          raise JobCancelled()

        retcode = proc.poll()
        if retcode is not None:
          stdout, stderr = proc.communicate()
          return subprocess.CompletedProcess(cmd, retcode, stdout, stderr)

        time.sleep(0.25)
    finally:
      if cancel_token and cancel_token.stopped and proc.poll() is None:
        try:
          proc.terminate()
        except Exception:
          pass
