"""Executor responsible for running Demucs for Noxsongizer jobs."""

from __future__ import annotations

import shutil
import subprocess
import tempfile
from pathlib import Path
from typing import List, Tuple

from app.models.job import Job


class NoxsongizerExecutor:
  """
  Isolated executor that runs Demucs for a given job input.

  Handles temporary output directories, subprocess execution, and moves the
  generated stems into the final job output folder.
  """

  def __init__(self, *, demucs_bin: str = "demucs", demucs_model: str = "htdemucs_ft", base_output: Path | None = None) -> None:
    """
    Initialize the executor.

    Args:
      demucs_bin: Demucs CLI executable.
      demucs_model: Demucs model name.
      base_output: Base directory for final outputs; defaults to media/outputs.
    """
    self.demucs_bin = demucs_bin
    self.demucs_model = demucs_model
    self.base_output = base_output or Path("media/outputs") / "noxsongizer"
    self.base_output.mkdir(parents=True, exist_ok=True)

  def execute(self, job: Job) -> Tuple[Path, List[str]]:
    """
    Run Demucs for the given job.

    Args:
      job: Job containing an input_path to process.

    Returns:
      A tuple of (final_output_dir, list_of_stems).

    Raises:
      ValueError: If input_path is missing or file does not exist.
      RuntimeError: If Demucs fails or outputs cannot be processed.
    """
    if not job.input_path:
      raise ValueError("Input file is missing")

    input_file = Path(job.input_path)
    if not input_file.exists():
      raise ValueError("Input file not found on disk")

    final_output_dir = self.base_output / job.id
    final_output_dir.mkdir(parents=True, exist_ok=True)

    input_stem = input_file.stem or "output"
    temp_dir = Path(tempfile.mkdtemp(prefix=f"{job.id}_", dir=str(self.base_output)))
    try:
      completed = self._run_demucs(input_file, temp_dir)
      if completed.returncode != 0:
        stderr = (completed.stderr or "").strip()
        raise RuntimeError(stderr or "Demucs failed")

      demucs_output_folder = self._locate_demucs_outputs(input_file, temp_dir)
      if not demucs_output_folder:
        raise RuntimeError("Demucs output folder not found")

      stems = self._move_outputs(demucs_output_folder, final_output_dir, input_stem)
      if not stems:
        raise RuntimeError("No stems generated by Demucs")

      return final_output_dir, stems
    finally:
      self._cleanup(temp_dir)

  def _run_demucs(self, input_file: Path, output_dir: Path) -> subprocess.CompletedProcess[str]:
    """
    Invoke Demucs and return the completed process.

    Args:
      input_file: Input audio file to separate.
      output_dir: Target directory for Demucs outputs.
    """
    cmd = [
      self.demucs_bin,
      "-n",
      self.demucs_model,
      "-o",
      str(output_dir),
      str(input_file),
    ]
    return subprocess.run(
      cmd,
      stdout=subprocess.PIPE,
      stderr=subprocess.PIPE,
      text=True,
      check=False,
    )

  def _locate_demucs_outputs(self, input_file: Path, base_dir: Path) -> Path | None:
    """
    Locate the Demucs output folder inside the temp directory.

    Args:
      input_file: Original input file.
      base_dir: Base directory where Demucs wrote its outputs.
    """
    candidate = base_dir / self.demucs_model / input_file.stem
    if candidate.exists():
      return candidate
    matches = list((base_dir / self.demucs_model).glob(f"{input_file.stem}*"))
    return matches[0] if matches else None

  def _move_outputs(self, source_dir: Path, target_dir: Path, input_stem: str) -> List[str]:
    """
    Move stem files from the Demucs output directory to the job output dir.

    Args:
      source_dir: Directory containing Demucs outputs.
      target_dir: Destination directory for the stems.
      input_stem: Stem of the original input filename for renamed outputs.
    """
    stems: List[str] = []
    for stem_path in source_dir.iterdir():
      if not stem_path.is_file():
        continue
      renamed = f"{input_stem}_{stem_path.stem}{stem_path.suffix}"
      target = target_dir / renamed
      shutil.move(str(stem_path), str(target))
      stems.append(renamed)
    return stems

  def _cleanup(self, path: Path) -> None:
    """Best-effort cleanup of temporary directories."""
    try:
      if path.exists():
        shutil.rmtree(path)
    except Exception:
      pass
