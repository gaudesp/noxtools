"""Executor responsible for running Demucs for Noxsongizer jobs."""

from __future__ import annotations

import shutil
from pathlib import Path
from typing import List

from app.errors import ExecutionError
from app.jobs.model import Job
from app.jobs.schemas import JobExecutionResult
from app.utils.files import ensure_path
from app.worker.cancellation import CancellationToken
from app.worker.process import run_process


class NoxsongizerExecutor:
  """
  Runs Demucs to split an audio file into stems.

  Contract:
    execute(job, cancel_token) -> JobExecutionResult

  Output policy:
    Everything happens inside the job directory:
      media/noxsongizer/outputs/<job_id>/
  """

  def __init__(
    self,
    *,
    demucs_bin: str = "demucs",
    demucs_model: str = "htdemucs_ft",
    base_output: Path | None = None,
  ) -> None:
    self.demucs_bin = demucs_bin
    self.demucs_model = demucs_model
    self.base_output = base_output or Path("media/noxsongizer/outputs")
    self.base_output.mkdir(parents=True, exist_ok=True)

  def execute(
    self,
    job: Job,
    *,
    cancel_token: CancellationToken | None = None,
  ) -> JobExecutionResult:
    if cancel_token:
      cancel_token.raise_if_cancelled()

    input_file = ensure_path(
      job.input_path,
      missing_message="Input file is missing",
      not_found_message="Input file not found on disk",
    )
    output_dir = self.base_output / job.id
    output_dir.mkdir(parents=True, exist_ok=True)
    input_stem = input_file.stem or "output"

    self._run_demucs(input_file, output_dir, cancel_token=cancel_token)

    demucs_output = self._locate_outputs(output_dir, input_file)
    if not demucs_output:
      raise ExecutionError("Demucs output folder not found")

    stems = self._move_stems(demucs_output, output_dir, input_stem)
    if not stems:
      raise ExecutionError("No stems generated by Demucs")

    self._cleanup_demucs_tree(output_dir)

    return JobExecutionResult(
      output_path=output_dir,
      output_files=stems,
      result={"stems": stems},
    )

  def _run_demucs(
    self,
    input_file: Path,
    output_dir: Path,
    *,
    cancel_token: CancellationToken | None,
  ) -> None:
    cmd = [
      self.demucs_bin,
      "-n",
      self.demucs_model,
      "-o",
      str(output_dir),
      str(input_file),
    ]
    run_process(cmd, cancel_token=cancel_token)

  def _locate_outputs(self, output_dir: Path, input_file: Path) -> Path | None:
    model_dir = output_dir / self.demucs_model
    if not model_dir.exists():
      return None

    candidate = model_dir / input_file.stem
    if candidate.exists():
      return candidate

    matches = list(model_dir.glob(f"{input_file.stem}*"))
    return matches[0] if matches else None

  def _move_stems(
    self,
    source_dir: Path,
    target_dir: Path,
    input_stem: str,
  ) -> List[str]:
    stems: List[str] = []

    for stem_path in source_dir.iterdir():
      if not stem_path.is_file():
        continue

      label = self._label_for_stem(stem_path.stem)
      renamed = f"[{label}] {input_stem}{stem_path.suffix}"
      target = target_dir / renamed

      shutil.move(str(stem_path), str(target))
      stems.append(renamed)

    return stems

  def _label_for_stem(self, stem_name: str) -> str:
    mapping = {
      "vocals": "Vocals",
      "other": "Other",
      "bass": "Bass",
      "drums": "Drums",
    }
    return mapping.get(stem_name.lower(), stem_name.title())

  def _cleanup_demucs_tree(self, output_dir: Path) -> None:
    """
    Demucs writes under:
      <job_dir>/<model>/<track>/*
    Once stems are moved to <job_dir>/, we can delete <job_dir>/<model>/ safely.
    """
    path = output_dir / self.demucs_model
    try:
      if path.exists():
        shutil.rmtree(path)
    except Exception:
      pass
